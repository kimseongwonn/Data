# -*- coding: utf-8 -*-
"""algorithm_study_02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XpxGN4AkYBTwN0vSGsPc3E3LQfu8A1Sn

두 번째 알고리즘 기초 실습 문제
- 팩토리얼 구하기
- 최대공약수 구하기
- 하노이의 탑 옮기기

최대공약수 구하기
"""

# 최대공약수 구하기
# 두 자연수 a와 b의 최대공약수를구하는 알고리즘을 만들어 보세요

# 입력값 : a, b
# 출력값 : a와 b의 최대 공약수

def gcd(a,b):
    i = min(a, b) # a와 b중 작은 수를 i에 저장
    while True:
        if (a % i == 0) and (b % i == 0): # i가 1이 되면 조건은 무조건 만족하게 되므로 종료조건
            return i
        i -= 1 # i를 1씩 감소시켜서 종료조건에 도달하게 하기

print(gcd(3, 6))
print(gcd(60, 24))
print(gcd(81, 27))

# 최대공약수 구하기
# 유클리그 알고리즘
# a, b의 최대 공약수는 b와 a를 b로 나눈 나머지의 최대공약수와 같음
# 즉 gcd(a, b) = gcd(b, a % b)
# 어떤 수와 0의 최대 공약수는 자기 자신
# gcd(n, 0) = n

# 따라서 gcd(60,24) = gcd(24, 60 % 24) = gcd(24, 12) = gcd(12, 24 % 12) = gcd(12, 0) = 12 >> 즉, 60과 24의 최대공약수는 12 라는 것을 알 수 있다.
# >> 재귀 호출로 최대 공약수를 구할 수 있다는 증거

def gcd2(a,b):
    if b == 0: # b가 영이되면 gcd(a,0) = a 이므로 a를 반환해준다 >> 종료 조건
        return a
    return gcd(b, a%b) # a%b로 값을 계속 감소시켜서 종료 조건이 되도록 해준다.

print(gcd(3, 6))
print(gcd(60, 24))
print(gcd(81, 27))

# 연습 문제
# 피보나치 수열이 0번부터 시작한다고 가정할 때 n번째 피보나치 수를 구하는 알고리즘을 재귀호출을 활용하여 만들기
# 피보나치 수열 : n번째 값이 n-2번째 값과 n-1번째 값의 합이 되는  수열

def fibo(n):
    if n <= 1:
        return n # n = 0 >> 0 / n = 1 >> 1
    return fibo(n-2) + fibo(n-1) # n이 감소되면서 결국 0 또는 1에 도달하여 종료조건을 만족 시키게 됨

print(fibo(5))

"""하노이의 탑 옮기기"""

# 하노이의 탑 옮기기
# 크기가 다른 원반 n개를 출발점 기둥에서 도착점 기둥으로 전부 옮겨야 함
# 원반은 한 번에 한 개씩만 옮길 수 있음
# 원반을 옮길 때는 한 기둥의 맨 위 원반을 뽑아, 다른 기둥의 맨 위로만 옮길 수 있음(기둥의 중간에서 원반을 빼내거나 빼낸 원반을 다른 기둥의 중간으로 끼워 넣을 수 없음).
# 원반을 옮기는 과정에서 큰 원반을 작은 원반 위로 올릴 수 없음

# 입력값 : 원반 개수 n, 옮길 원반이 현재 있는 출발점 기둥 from_pos, 원반을 옮길 도착점 기둥 to_pos, 옮기는 과정에서 사용할 보조 기둥 aux_pos
# 출력값 : 원반을 옮기는 순서

# 알고리즘 단순화
# n개의 원판이 있는 경우
# 1. 가장 큰 원판을 제외한 모든 원판이 ap에 있도록한다.
# 2. 가장 큰 원판을 tp로 옮긴다.
# 3. ap에 있는 원판을 전부 tp로 옮긴다.

# 여기서 1과 3의 과정은 n-1개의 원판이 있는 경우의 1,2,3을 반복하면 된다.
# 즉 'n개의 원판을 옮기는 횟수'는 'n-1개 원판을 옮기는 횟수' + 1 + 'n-1개 원판을 옮기는 횟수' 이다.

def hanoi(n, fp, tp, ap):
    if n == 1: # n 이 줄어들어 1이되면 종료하게 되는 종료 조건
        print(fp, "->", tp)
        return
    hanoi(n-1, fp, ap, tp) # 1. 가장 큰 원판을 제외한 모든 원판이 ap에 있도록한다.
    print(fp, "->", tp) # 2. 가장 큰 원판을 tp로 옮긴다.
    hanoi(n-1, ap, tp, fp) # 3. ap에 있는 원판을 전부 tp로 옮긴다.

print('n=1')
print(hanoi(1,'fp', 'tp', 'ap'))
print()
print('n=2')
print(hanoi(2,'fp', 'tp', 'ap'))
print()
print('n=3')
print(hanoi(3,'fp', 'tp', 'ap'))

"""### 세 번째 알고리즘 기초 실습 문제 ###
- 순차 탐색
- 선택 정렬
- 삽입 정렬
- 병합 정렬
- 퀵 정렬
- 이분 탐색

순차 탐색
"""

# 순차 탐색
# 주어진 리스트에 특정한 값이 있는지 찾아 그 위치를 돌려주는 알고리즘
# 리스트에 찾는 값이 없다면 -1을 반환

# 입력값 : 리스트 x와 찾는 값 n
# 출력값 : 찾는 값의 위치 인덱스 또는 -1

def loca(x, n):
    for i in range(len(x)):
        if x[i] == n:
            return i
    return -1

l = [15, 80, 34, 564, 30, 43, 56, 8]

print(loca(l,30))
print(loca(l,100))

# 순차 탐색의 경우 찾는 값이 리스트 처음부분에 있으면 쉽게 찾아지지만 최악의 경우 마지막에 있으면 처음부터 마지막까지 하나씩 다 비교해야함
# 따라서 최악의 경우를 비교했을때 리스트의 길이가 길어지면 계산 횟수가 늘어나므로 O(n)으로 표기 가능

# 연습문제
# 리스트에서 찾는 값이 여러개 있더라도 첫 번째 위치만 돌려주는 알고리즘을 변형시켜 찾는 값이 여러개 있을때 찾는 값의 모든 위치를 리스트로 돌려주는 알고리즘을 만들기
# 찾는 값이 없다면 빈 리스트를 반환

def loca2(x, n):
    res = [] # 결과값을 담아서 출력할 빈 리스트 생성
    for i in range(len(x)):
        if x[i] == n: # 찾는 값이 리스트안 요소와 같으면 해당 요소의 인덱스를 res 리스트에 추가
            res.append(i)
    return res

l = [15, 80, 30, 564, 30, 43, 56, 8]

print(loca2(l,30))
print(loca2(l,100))

# 학생 번호에 해당하는 학생 이름 찾기
# 입력값 : 학생 번호 리스트, 학생 이름 리스트, 찾는 학생 번호
# 출력값 : 해당하는 학생 이름, 학생 이름이 없으면 물음표'?' 출력

def search_name(num, name, n):
    for i in range(len(num)):
        if num[i] == n:
            return name[i]
    return '?'

num = [1,2,3,4,5]
name = ['길동', '길수', '민지', '민수', '예은']

print(search_name(num, name, 4))

"""선택 정렬"""

# 선택 정렬
# 주어진 리스트 안의 자료를 작은 수부터 큰 수 순서로 배열하는 정렬 알고리즘
# 정렬(sort): 자료를 크기 순서대로 정렬

# 입력값 : 정렬할 리스트
# 출력값 : 정렬된 리스트

# 1. 새로운 리스트에 최소값을 차례대로 넣어주는 알고리즘
def min_i(x):
    min_idx = 0 # 최소값 인덱스 초기화

    for i in range(1, len(x)):
        if x[i] < x[min_idx]: # 만약 i를 인덱스로 가지는 값이 최소값보다 작다면 최소값의 인덱스를 해당 값의 인덱스로 변경
            min_idx = i

    return min_idx

def sort_list(a):
    res = []
    while a: # 리스트 a의 범위안에서 동작
        min_idx = min_i(a)
        value = a.pop(min_idx) # value는 리스트 a에서 최소값이 떨어져 나와서 들어감
        res.append(value) # 리스트 res에 떨어져 나온 value 값이 하나씩 들어간다. >> 즉, 최소값부터 차례대로 누적되어 들어가게 된다.
    return res


l = [5,3,4,2,1,6]
print(min_i(l)) # 최소값의 인덱스가 출력된다.
print()
print(sort_list(l))

# 2. 주어진 리스트 안에서 재배치 하는 알고리즘

def sort_list2(a):
    n = len(a)
    for i in range(n-1): # 0부터 n-2까지 반복 >> 0~(n-2)까지가 n-1개 / 마지막 n번째꺼는 비교할 필요 없음(앞에서 이미 다 비교되기 때문)
        min_idx = i
        for j in range(i+1, n): # (i+1) ~ n >> i 다음꺼부터 비교해서 n번째 마지막 요소까지 비교
            if a[j] < a[min_idx]: # a[i]보다 a[j]가 작으면 min_idx를 j로 바꿔준다.
                                    # 1단계 : a[i]와 a[i+1]을 비교한 뒤 작은 값을 min_idx에 넣는다
                                    # 2단계 : 1단계에서 정해진 작은 값과 a[i+2]를 비교하여 작은 값을 min_idx에 넣는다
                                    # 3단계 : 2단계를 n까지 계속 반복하여 최종적으로 가장 작은 값의 인덱스가 min_idx에 담기게 된다.
                min_idx =j

        a[i], a[min_idx] = a[min_idx], a[i] # 앞서 구한 가장 작은 값의 인덱스 min_idx를 이용하여 위치를 바꿔준다.
        # 위치를 바꿔주는 코드
        # a[i], a[min_idx]의 순서를 = a[min_idx], a[i] 이렇게 바꿔주겠다.

l = [5,3,4,2,1,6]
sort_list2(l)
print(l)

# 연습 문제
# 내림차순으로 정렬하도록 알고리즘 바꾸기

def sort_desc(a):
    n = len(a)
    for i in range(n-1):
        min_idx = i
        for j in range(i+1, n):
            if a[j] > a[min_idx]: # '<'를 '>'로 바꿔주기만 하면 된다

                min_idx =j

        a[i], a[min_idx] = a[min_idx], a[i]

l = [5,3,4,2,1,6]
sort_desc(l)
print(l)

"""삽입 정렬"""

# 삽입 정렬

# 1. 새로운 리스트에 값을 정렬하는 알고리즘

# 리스트 r에서 v가 들어가야할 idx를 돌려주는 함수
def find_ins_idx(r, v):
    for i in range(len(r)): # 0 ~ 리스트r의 크기
        if v < r[i]: # 만약 v의 값이 i번째 값보다 작으면
            return i # v가 들어갈 idx는 i
    return len(r) # 그게 아니라면 v를 가장 마지막에 넣기 위해 len(r)을 idx 값으로 반환

def ins_sort(a):
    res = [] # 결과값이 새롭게 정렬될 빈 리스트
    while a: # 리스트 a에 자료가 남아있다면 True
        value = a.pop(0) # 리스트 a에서 인덱스 0번째 값을 하나씩 추출해서 value로 사용 >> 하나씩 pop되므로 리스트 a의 요소들이 하나씩 줄어든다
        ins_idx = find_ins_idx(res, value) # 리스트 res와 value를 함수 find_ins_idx를 사용하여 value의 위치값 추출
        res.insert(ins_idx, value) # 추출된 value의 위치에 value 삽입
    return res

d = [2,4,5,1,3]
print(ins_sort(d))

# 2. 주어진 리스트 안에서 재배치 하는 알고리즘

def ins_sort2(a):
    n = len(a)
    for i in range(1, n): # i에 1부터 n-1까지 차례대로 들어감
        key = a[i] # key를 idx 가 i인 리스트 a의 요소값으로 지정
        j = i - 1 # j를 i 왼쪽에 배치해주기 위해 -1함

        while j >= 0 and a[j] > key: # j가 0보다 크거나 같고 idx 를 j로 가지는 리스트 a의 값이 key보다 크면
            a[j+1] = a[j] # 삽입할 공간 확보를 위해서 a[j]를 j+1의 위치로 이동


            j = j - 1 # 삽입할 위치 조정

        a[j+1] = key # 찾은 위치에 key 저장

d = [2,4,5,1,3]
ins_sort2(d)
print(d)

# 연습 문제

# 내림차순

def ins_sort2(a):
    n = len(a)
    for i in range(1, n):
        key = a[i]
        j = i - 1

        while j >= 0 and a[j] < key: # '>'를 '<'로 바꿔준다
            a[j+1] = a[j]


            j = j - 1

        a[j+1] = key

d = [2,4,5,1,3]
ins_sort2(d)
print(d)

"""병합 정렬"""

# 병합 정렬

def merge_sort(a):
    n = len(a)
    if n <= 1: # 종료 조건
        return a

    mid = n // 2 # 중간값 idx
    g1 = merge_sort(a[:mid]) # 재귀 호출로 첫번째 그룹을 정렬
    g2 = merge_sort(a[mid:]) # 재귀 호출로 두번째 그룹을 정렬

    res = [] # 두 그룹 비교 결과를 담을 빈 리스트 생성
    while g1 and g2: # 두 그룹 모두 자료가 남아 있는 동안 반복
        if g1[0] < g2[0]: # 두그룹의 첫번째 요소의 값 크기를 비교
            res.append(g1.pop(0))
        else:
            res.append(g2.pop(0))

    # 나머지 요소들도 마저 비교해서 결과 리스트에 삽입
    while g1:
        res.append(g1.pop(0))
    while g2:
        res.append(g2.pop(0))
    return res

d = [6, 8, 3, 9, 10, 1, 2, 4, 7, 5]
print(merge_sort(d))

# 병합 정렬 일반 버전

def merge_sort(a):
    n = len(a)
    if n <= 1:
        return

    # 재귀 호출로 두 그룹으로 나눈뒤 정렬
    mid = n // 2
    g1 = a[:mid]
    g2 = a[mid:]
    merge_sort(g1)
    merge_sort(g2)

    i1 = 0 # g1 의 인덱스값
    i2 = 0 # g2 의 인덱스값
    ia = 0 # a의 인덱스값

    while i1 < len(g1) and i2 < len(g2): # g1의 위치 정보가 마지막보다 작고 g2의 위치 정보가 마지막보다 작은 동안 반복
        if (g1[i1] < g2[i2]): # g1의 값이 작으면
            a[ia] = g1[i1] # a에 g1값 삽입
            i1 += 1
            ia += 1
        else:
            a[ia] = g2[i2] # g2의 값이 작으면 a에 g2값 삽입
            i2 += 1
            ia += 1

    # 남은 요소들도 비교해서 리스트에 넣어주기
    while i1 < len(g1):
        a[ia] = g1[i1]
        i1 += 1
        ia += 1

    while i2 < len(g2):
        a[ia] = g2[i2]
        i2 += 1
        ia += 1

d = [6, 8, 3, 9, 10, 1, 2, 4, 7, 5]
merge_sort(d)
print(d)

