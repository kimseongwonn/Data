# -*- coding: utf-8 -*-
"""algorithm_study_03.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WHGI_UhFu-APC8JHNLcYeTmfAxYad5Zo

### 세 번째 알고리즘 기초 실습 문제 ###
- 순차 탐색
- 선택 정렬
- 삽입 정렬
- 병합 정렬
- 퀵 정렬
- 이분 탐색

퀵정렬
"""

# 퀵정렬

def quick_sort(a):
    n = len(a)
    if n <= 1: # 종료 조건 : 피벗을 정해서 계속해서 리스트를 쪼개다가 쪼개진 리스트의 길이가 1보다 작거나 같으면 더이상 쪼갤 것이 없음
        return a

    pivot = a[-1] # 피벗을 리스트의 가장 마지막 값으로 임의 지정 >> 피벗은 아무 값이나 잡아도 상관 없음
    g1 = [] # 쪼개진 리스트를 담을 빈 리스트 생성
    g2 = []

    for i in range(n-1): # 피벗 값이 마지막 값이므로 n-1까지
        if a[i] < pivot:
            g1.append(a[i])
        else:
            g2.append(a[i])

    return quick_sort(g1) + [pivot] + quick_sort(g2) # 리스트 + 리스트 + 리스트로 새로운 리스트 만들어 줌

d = [6, 8, 3, 9, 10, 1, 2, 4, 7, 5]
print(quick_sort(d))

# 일반 적인 퀵정렬

def quick_sort_sub(a, start, end):
    if end - start <= 0:
        return

    pivot = a[end]
    i = start
    for j in range(start, end): # start == 0 , end == len(a)-1
        if a[j] <= pivot: # j는 0~8까지 1씩 증가함 >> 리스트 a의 0번째부터 8번째까지 pivot값과 비교하여 리스트 a[j]의 값이 작으면
            a[i],a[j] = a[j],a[i] # a[i]값하고 자리를 바꿔주는데
            i += 1 # 조건이 참이면 i는 1씩 증가해서 a[i]가 오른쪽으로 한 칸씩 가도록 함 >> pivot보다 작은 값이 있는 개수만큼 증가한다
    a[i], a[end] = a[end], a[i] # 마지막으로 a[i]와 비교 기준인 pivot(a[end])를 바꿔줌

    quick_sort_sub(a, start, i - 1)
    quick_sort_sub(a, i + 1, end)

def quick_sort(a):
    quick_sort_sub(a, 0, len(a)-1)


# 리스트 d에 대한 함수 연산 과정
# quick_sort 함수 >> a = d, start = 0, end = len(d) - 1
# quick_sort_sub 함수
# pivot = d[9] = 5
# i = start = 0
# j의 범위 : range(0,9)
# for문 동작 과정
# 1) d[0](==6)과 pivot(==5) 비교 > 조건 거짓 > 넘어감
# 2) d[1](==8)과 pivot(==5) 비교 > 조건 거짓 > 넘어감
# 3) d[2](==3)과 pivot(==5) 비교 > 조건 참 > a[i],a[j] = a[j],a[i] 발동 > 6과 3 자리 바뀜 > i에 1추가됨 > i = 1
# 4) d[3](==9)과 pivot(==5) 비교 > 조건 거짓 > 넘어감
# 5) d[4](==10)과 pivot(==5) 비교 > 조건 거짓 > 넘어감
# 6) d[5](==1)과 pivot(==5) 비교 > 조건 참 > a[i],a[j] = a[j],a[i] 발동 > 8과 1 자리 바뀜 > i에 1추가됨 > i = 2
# 7) d[6](==2)과 pivot(==5) 비교 > 조건 참 > a[i],a[j] = a[j],a[i] 발동 > 6과 2 자리 바뀜 > i에 1추가됨 > i = 3
# 8) d[7](==4)과 pivot(==5) 비교 > 조건 참 > a[i],a[j] = a[j],a[i] 발동 > 9과 4 자리 바뀜 > i에 1추가됨 > i = 4
# 9) d[8](==7)과 pivot(==5) 비교 > 조건 거짓 > 넘어감
# 10) for 문 종료 > a[i], a[end] = a[end], a[i] 실행 > 10과 5 자리 바뀜
# 11) 재귀 호출로 quick_sort_sub(d, 0, 4-1)과 quick_sort_sub(d, 4+1,9)가 돌아가고 나온 결과값에서 또 재귀 호출을 반복...반복...반복하여 종료조건 end - start <= 0을 만족하게되어 함수 종료

d = [6, 8, 3, 9, 10, 1, 2, 4, 7, 5]
quick_sort(d)
print(d)

"""버블 정렬"""



"""이분 탐색"""

# 이분 탐색
# 자료의 크기 순서대로 정렬된 리스트에서 특정한 값이 있는지 찾아 그 위치를 돌려주는 알고리즘

# 순차 탐색은 하나씩 탐색하므로 효율적이지 못함
# 이러한 점을 보완하기 위해 탄생한 것이 이분 탐색
# 중간 값을 기준으로 찾는 값이 중간 값보다 작은지 큰지를 비교하여 표본의 크기를 절반으로 계속 줄여나가는 방식

def binary_search(a, x): # 리스트 a에서 찾을 값 x
    start = 0
    end = len(a)

    while start <= end: # start가 end보다 커지면 끝남
        mid = (start + end) // 2 # 중간 위치 설정

        if x ==  a[mid]: # 만약 찾는 값이 중간 위치에 있으면 중간 위치 값을 반환
            return mid
        elif x > a[mid]: # 찾는 값이 중간 위치 값보다 크면 start 지점을 오른쪽으로 한칸 이동
            start = mid + 1
        else: # 찾는 값이 중간 위치 값보다 작으면 end 지점을 왼쪽으로 한칸 이동
            end = mid - 1

    return -1 # 찾는 값이 없으면 -1 반환

d = [1, 4, 9, 16, 25, 36, 49, 64, 81]
print(binary_search(d, 36))
print(binary_search(d, 50))

# 재귀 호출을 이용한 이분 탐색